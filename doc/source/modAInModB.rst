Instantiating a hardened module **A** twice in a module **B**
=============================================================

Hardened modules allow predictable timing, efficient placement, and scalable
hierarchical ASIC design.

This tutorial demonstrates how to use Silicon Compiler to harden a
Verilog module as a reusable macro, and then instantiate it multiple times in
another module by:

1. Writing a simple Verilog module **A**
2. Synthesizing, placing, and routing **A** using Silicon Compiler
3. Packaging the resulting layout and timing models from **A** as a hard macro
4. Instantiating the hard macro **A** twice inside a second module **B**
5. Running the ASIC flow on module **B**

All these steps are contained in the single Python script detailed below.

The script is also available at: <https://github.com/philiprbrenan/siliconCompiler_modAInModB/blob/main/top.py>

The execution of this script can be seen at:

<https://github.com/philiprbrenan/siliconCompiler_modAInModB/actions>

.. contents::
   :depth: 2
   :local:

Environment Setup
-----------------

Import the tools to be used:

.. code-block:: python

    
    import os
    from pathlib import Path
    
    from siliconcompiler import Design, ASIC, StdCellLibrary
    from siliconcompiler.flows import asicflow
    from siliconcompiler.targets import skywater130_demo
    from siliconcompiler.schema_support.option import OptionSchema
    from siliconcompiler.tools import get_task
    from siliconcompiler.tools.klayout import KLayoutLibrary
    from siliconcompiler.tools.openroad import OpenROADStdCellLibrary
    from siliconcompiler.tools.openroad.write_data import WriteViewsTask
    from siliconcompiler.tools.yosys import YosysStdCellLibrary
    


Parameters
----------

These parameters determine the size of the design and the names of the
modules in the design.

.. code-block:: python

    A = "A"                                                                         # Module A to be instantiated multiple times
    B = "B"                                                                         # Module B contains several uses of module A
    N =  8                                                                          # Width of each data path
    
    SIZE   = 300                                                                    # Size of die containing design
    BORDER =  10                                                                    # Border around core area


Files used
----------
These files will contain the Verilog generated by this script.

.. code-block:: python

    workdir  = "."
    file_a   = os.path.join(workdir, f"{A}.v")                                      # Verilog for module A
    file_b   = os.path.join(workdir, f"{B}.v")                                      # Verilog for module B
    clk_file = os.path.join(workdir, "top.sdc")                                     # Clock definition


Step 1: Create Verilog for module **A**
---------------------------------------

**A** is a simple ``AND`` gate with a registered output triggered by the clock.

.. code-block:: python

    verilog_a = f"""
    module {A}(
        input  wire          clk,
        input  wire[{N}-1:0] a,
        input  wire[{N}-1:0] b,
        output reg [{N}-1:0] y
    );
    
      always @ (posedge clk) begin
        y = a & b;
      end
    endmodule
    """
    
    with open(file_a, "w") as f:
      f.write(verilog_a)
    
    with open(clk_file, "w") as f:
        f.write(f"create_clock -name clk -period 100 [get_ports clk]\n")


Step 2: Synthesize, Place & Route module **A**
----------------------------------------------

The following code will build module **A** with the Silicon Compiler default
``ASIC`` flow:

.. code-block:: python

    design_a = Design(A)
    
    design_a.set_dataroot(A, __file__)
    design_a.add_file(f"{A}.v", fileset='verilog')
    design_a.set_topmodule(A, fileset='verilog')
    
    project_a = ASIC(design_a)
    project_a.add_fileset(['verilog'])
    skywater130_demo(project_a)
    
    project_a.run()
    project_a.summary()


Run the code above in a Silicon Compiler Python virtual environment
to synthesize, place and route module **A**:

.. image:: _images/A.png
   :alt: Module A diagram
   :align: center
   :width: 400px

Step 3: Create a Macro Library Class from **A**
-----------------------------------------------

Take the generated ``LEF``, ``GDS``, and ``Liberty`` files and package them into a
custom library class so **A** can be instantiated as a hard macro.

Define a class that inherits from the relevant tools and
provides them with the locations of the files generated by Silicon Compiler
during the processing of module **A**.

.. code-block:: python

    class ModA(YosysStdCellLibrary, OpenROADStdCellLibrary, KLayoutLibrary):
      def __init__(self, modA):
        super().__init__()
        self.set_name(f"mod{A}")
    
        self.add_asic_pdk(modA.get("asic", "pdk"))
    
        with self.active_fileset("models.physical"):
          self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.lef")
          self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.slow.lib")
          self.add_file(f"./build/{A}/job0/write.gds/0/outputs/{A}.gds")
          self.add_asic_aprfileset()
    
        with self.active_fileset("models.timing.nldm"):
          self.add_file(f"./build/{A}/job0/write.views/0/outputs/{A}.slow.lib")
          self.add_asic_libcornerfileset("generic", "nldm")


Step 4: Create Verilog for a module **B** that instantiates **A**
-----------------------------------------------------------------------

Module **B** instantiates **A** as a hard macro several times.

.. code-block:: python

    verilog_b = f"""
    module {B}(
        input  wire          clk,
        input  wire[{N}-1:0] a1,
        input  wire[{N}-1:0] b1,
        input  wire[{N}-1:0] a2,
        input  wire[{N}-1:0] b2,
        output reg [{N}-1:0] y
    );
    
        reg[{N}-1:0] d1;
        reg[{N}-1:0] d2;
    
        {A} D1 (.clk(clk), .a(a1), .b(b1), .y(d1));
        {A} D2 (.clk(clk), .a(a2), .b(b2), .y(d2));
        {A} Y  (.clk(clk), .a(d1), .b(d2), .y(y));
    endmodule
    """
    
    with open(file_b, "w") as f:
        f.write(verilog_b)


Step 5: Build **B** with **A** as a Custom Library
--------------------------------------------------

Configure Silicon Compiler to treat ``modA`` as an available macro
in the ``ASIC`` flow for **B**.

.. code-block:: python

    design_b = Design(B)
    
    design_b.set_dataroot(B, __file__)
    design_b.add_file(f"{B}.v", fileset='verilog')
    design_b.set_topmodule(B, fileset='verilog')
    
    project_b = ASIC(design_b)


Setting core and die area correctly is crucial for successful macro placement.

.. code-block:: python

    project_b.constraint.area.set_diearea_rectangle(SIZE, SIZE)                     # Silicon area occupied by the design
    project_b.constraint.area.set_corearea_rectangle(SIZE-BORDER*2, SIZE-BORDER*2, (BORDER, BORDER))
    
    project_b.add_fileset(['verilog'])
    project_b.add_asiclib(ModA(project_a))                                          # Add the hard macro for module A
    skywater130_demo(project_b)                                                     # Technology being used
    
    task = get_task(project_b, filter=WriteViewsTask)                               # Instance of the WriteViewsTask in the flowgraph
    task.set("var", "ord_enable_images", False)                                     # Disable the image generation (including the gif) that is failing for the write.data step
    
    project_b.run()
    project_b.summary()


Run the code above in the Silicon Compiler Python virtual environment
to synthesize, place and route module **B**:

.. image:: _images/B.png
   :alt: Module B diagram
   :align: center
   :width: 400px

Conclusion
----------

This tutorial demonstrates how to perform a basic modular hierarchical ``ASIC`` design flow in
Silicon Compiler by:

- Hardening a leaf module **A**
- Exporting the layout and timing views from **A** as a custom library ``modA``
- Instantiating ``modA`` in the parent module **B**

This approach enables scalable chip design with reusable hardened blocks.
